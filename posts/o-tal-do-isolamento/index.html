<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>O tal do Isolamento no A.C.I.D. - Alen Vieira</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="O tal do Isolamento no A.C.I.D."><meta itemprop=description content="Vamos aprofundar um pouco sobre o isolamento?"><meta itemprop=datePublished content="2024-06-02T09:38:53-03:00"><meta itemprop=dateModified content="2024-06-02T09:38:53-03:00"><meta itemprop=wordCount content="4131"><meta itemprop=keywords content><meta property="og:title" content="O tal do Isolamento no A.C.I.D."><meta property="og:description" content="Vamos aprofundar um pouco sobre o isolamento?"><meta property="og:type" content="article"><meta property="og:url" content="https://alenvieira.github.io/posts/o-tal-do-isolamento/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-02T09:38:53-03:00"><meta property="article:modified_time" content="2024-06-02T09:38:53-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="O tal do Isolamento no A.C.I.D."><meta name=twitter:description content="Vamos aprofundar um pouco sobre o isolamento?"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://alenvieira.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://alenvieira.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://alenvieira.github.io/css/dark.css><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://alenvieira.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://alenvieira.github.io/>Alen Vieira</a></h1><div class=site-description><p>Compartilhando ou documentando questões</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/alenvieira title=Github><i data-feather=github></i></a></li><li><a href=https://twitter.com/alen_vieira title=Twitter><i data-feather=twitter></i></a></li><li><a href=../../index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=../../>Home</a></li><li><a href=../../posts>Posts</a></li><li><a href=../../about>Sobre</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>02</span>
<span class=rest>Jun 2024</span></div></div><div class=matter><h1 class=title>O tal do Isolamento no A.C.I.D.</h1></div></div><div class=markdown><blockquote><p>A solidão é estar sozinho; o isolamento é achar-se só no mundo quando se está só. Diane de Beausacq</p></blockquote><p>Isolamento no A.C.I.D. é a garantia responsável por gerenciar a concorrência entre as transações e verificar como as transações simultâneas podem afetar umas às outras. Como tratei <a href=../../posts/explicando-acid/>no artigo passado</a>.</p><p>Vamos utilizar Python com algumas bibliotecas para trabalhar com PostgreSQL em um container, como abordado no artigo anterior. Realizaremos diversos testes para demonstrar diferentes cenários de isolamento. Os detalhes podem ser encontrados no repositório.</p><p>Vale lembrar que, ao utilizar conexões criadas com a estrutura &ldquo;with&rdquo;, todas as operações serão confirmadas (commit) se concluídas com sucesso durante a conexão; caso contrário, tudo será revertido (rollback). Em ambos os casos, a conexão será encerrada automaticamente.</p><pre><code>&quot;Ok! Cara, está tudo muito confuso! Pode me dar um exemplo? Como podemos identificara importância do isolamento?&quot;  
</code></pre><p>Certo, vamos lá: imagine que seu gerente está considerando te dar um aumento ao mesmo tempo em que a empresa está realizando um reajuste salarial global. Se ambas as operações forem executadas ao mesmo tempo, diferentes cenários podem afetar seu salário:</p><ul><li>No melhor cenário, você recebe os aumentos na ordem que mais te beneficie.</li><li>Um dos aumentos pode ser perdido se um sobrepuser o outro.</li><li>Um dos aumentos pode gerar um erro.</li></ul><p>Isso depende de como está configurada a visibilidade de uma transação em relação à outra.</p><p>Vamos aprender um pouco mais sobre isso começando pelos níveis de isolamento existentes.</p><h2 id=níveis-de-isolamento>Níveis de isolamento</h2><p>O padrão SQL define quatro níveis de isolamento:</p><ul><li><strong>Read uncommitted</strong>(Leitura não commitada): Nível menos restritivo que permite ler dados de outras transações que ainda não foram commitados ou confirmados, podendo levar a dirty reads (leituras sujas), non-repeatable reads (leituras não repetíveis), lost updates (atualizações perdidas), read skew (distorções de leitura), write skew (distorções de escrita) e phantom reads (leituras fantasmas).</li><li><strong>Read committed</strong>(Leitura commitada): Nível onde a transação pode ler apenas dados de transações que foram commitadas ou confirmadas, evitando leituras sujas, mas ainda permitindo non-repeatable reads, lost updates, read skew, write skew e phantom reads.</li><li><strong>Repeatable read</strong>(Leitura repetida): Nível que garante que os dados lidos durante a transação não serão alterados até que a transação seja concluída, evitando leituras non-repeatable reads, mas permitindo fenômenos de lost updates, read skew, write skew e phantom reads.</li><li><strong>Serializable</strong>(Serializável): Nível de isolamento mais restritivo, que garante que as transações sejam completamente isoladas umas das outras, evitando qualquer interferência e fenômenos como dirty reads, non-repeatable reads, lost updates, read skew, write skew e phantom reads.</li></ul><h2 id=principais-fenômenos>Principais Fenômenos</h2><p>Alguns fenômenos podem ser causados por interferência das transações executadas simultaneamente, dependendo da configuração do nível do isolamento. Abaixo, vemos alguns dos fenômenos em que níveis de isolamento podem ocorrer:</p><table><thead><tr><th rowspan=2 style="border:1px solid #000;text-align:center;vertical-align:middle">Nível de isolamento</th><th colspan=6 style="border:1px solid #000;text-align:center;vertical-align:middle">Fenômenos</th></tr><tr><th style="border:1px solid #000;text-align:center;vertical-align:middle">Dirty Read</th><th style="border:1px solid #000;text-align:center;vertical-align:middle">Nonrepeatable Read</th><th style="border:1px solid #000;text-align:center;vertical-align:middle">Lost Update</th><th style="border:1px solid #000;text-align:center;vertical-align:middle">Read Skew</th><th style="border:1px solid #000;text-align:center;vertical-align:middle">Write Skew</th><th style="border:1px solid #000;text-align:center;vertical-align:middle">Phantom Read</th></tr></thead><tbody><tr><td style="border:1px solid #000;text-align:center;vertical-align:middle"><b>Read uncommitted</b></td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer, mas <b>não ocorre</b> no PostgreSQL*</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td></tr><tr><td style="border:1px solid #000;text-align:center;vertical-align:middle"><b>Read committed</b></td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer</td></tr><tr><td style="border:1px solid #000;text-align:center;vertical-align:middle"><b>Repeatable read</b></td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre, mas <b>pode ocorrer</b> no PostgreSQL*</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Pode ocorrer, mas <b>não ocorre</b> no PostgreSQL*</td></tr><tr><td style="border:1px solid #000;text-align:center;vertical-align:middle"><b>Serializable</b></td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td><td style="border:1px solid #000;text-align:center;vertical-align:middle">Não ocorre</td></tr></tbody></table><p><strong>Tabela dos principais fenômenos nos diferentes níveis de isolamento.</strong> Fonte: Compilação do autor a partir de <a href=https://www.postgresql.org/docs/16/transaction-iso.html#MVCC-ISOLEVEL-TABLE><em>Tabela de Níveis de isolamento de transação da Documentação do PostgreSQL</em></a>, do artigo <a href=https://arxiv.org/pdf/cs/0701157.pdf><em>A Critique of ANSI SQL Isolation Levels</em></a> e do post <a href=https://vladmihalcea.com/a-beginners-guide-to-read-and-write-skew-phenomena/><em>A beginner’s guide to Read and Write Skew phenomena</em></a>.</p><p><strong>*</strong> Dependendo do banco de dados utilizado, suas implementações sobre as garantias do isolamento podem ser ligeiramente diferentes. Como vamos utilizar o PostgreSQL, resolvi incorporar as informações específicas desse banco de dados que diferem em três pontos com relação ao fenômeno e nível de isolamento que não acompanham o padrão SQL.</p><h3 id=dirty-read>Dirty Read</h3><p>Dirty Read ou Leitura Suja é o fenômeno em que a transação pode ler dados que ainda não foram commitados ou confirmados. No PostgreSQL, onde irei executar os testes, o nível de isolamento <strong>Read Uncommitted</strong> não é realmente implementado. Ele está presente apenas por compatibilidade, e não é possível reproduzir esse fenômeno no nesse banco de dados porque o nível de isolamento real é <strong>Read Committed</strong>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_dirty_read(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SHOW TRANSACTION ISOLATION LEVEL&#34;</span>)
</span></span><span style=display:flex><span>            default_transaction_isolation, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED&#34;</span>)
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SHOW TRANSACTION ISOLATION LEVEL&#34;</span>)
</span></span><span style=display:flex><span>            new_transaction_isolation, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;John Smith&#34;</span>, 2500))
</span></span><span style=display:flex><span>            id_employee, = cur.fetchone()
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (3500, id_employee))
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>global</span> dirty_read_salary
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                dirty_read_salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()         
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>            new_salary, = cur.fetchone()            
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(default_transaction_isolation, <span style=color:#a31515>&#34;read committed&#34;</span>)
</span></span><span style=display:flex><span>    self.assertEqual(new_transaction_isolation, <span style=color:#a31515>&#34;read uncommitted&#34;</span>)
</span></span><span style=display:flex><span>    self.assertEqual(dirty_read_salary, 2500)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary, 3500)
</span></span></code></pre></div><p>Nesse teste, primeiramente verificamos qual é o nível de isolamento padrão no PostgreSQL e fizemos uma operação para mudar o nível de isolamento. Após isso, executamos um cenário de dirty read com os seguintes passos entre as transações:</p><p><img src=../../images/dirty_read.svg alt="A imagem mostra um diagrama de sequência com três colunas rotuladas como T1, Database e T2. As interações são as seguintes: Na coluna T1: Uma ação rotulada como &ldquo;Atualiza salário do funcionário&rdquo; envia uma seta para a coluna Database. Outra ação rotulada como &ldquo;Confirma transação&rdquo; envia uma seta para a coluna Database. Na coluna T2: Uma ação rotulada como &ldquo;Seleciona funcionário&rdquo; envia uma seta para a coluna Database.
O diagrama ilustra uma sequência onde T1 atualiza e confirma a transação do salário de um funcionário no banco de dados, enquanto T2 seleciona um funcionário do banco de dados. Existe uma relação temporal explicitada na imagem na qual T2 inicia-se após T1, mas é finalizada antes de T1."></p><ul><li>Primeira transação(T1) começa realizando uma operação de atualização do salário de um funcionário.</li><li>A segunda transação(T2) seleciona o salário do mesmo funcionário. Ela tem seu inicio e é confirmação antes do término de T1.</li><li>Por fim, é confirmado/commitado a transação T1 após a finalização de T2.</li></ul><p>No nível de isolamento <strong>Read Uncommitted</strong>, a segunda transação deveria ler o valor não confirmado/commitado da primeira transação, resultando no fenômeno de dirty read. No entanto, isso não ocorre no PostgreSQL, como podemos confirmar nas asserções. As asserções verificam as seguintes questões:</p><ul><li>O nível de isolamento padrão no PostgreSQL é <strong>Read Committed</strong>;</li><li>Verifica-se a mudança no nível de isolamento da transação;</li><li>Há confirmação de que não houve a leitura suja;</li><li>E que a alteração do salário realmente ocorreu.</li></ul><p>Por fim, verificamos nos testes que o nível de isolamento padrão é <strong>Read Committed</strong> e que o fenômeno Dirty Read não acontece no PostgreSQL. Sendo uma questão específica de cada banco de dados.</p><h3 id=nonrepeatable-read>Nonrepeatable Read</h3><p>Nonrepeatable Read ou Leitura Não Repetível, também conhecido por Fuzzy Read, é um fenômeno em que uma transação lê um registro duas vezes e obtém resultados diferentes. Pode ocorrer no PostgreSQL quando está no nível de isolamento <strong>Read Committed</strong>, mas não ocorre no <strong>Repeatable Read</strong>. Na imagem abaixo, mostramos o funcionamento desse fenômeno:</p><p><img src=../../images/nonrepeatable_read.svg alt=image></p><ul><li>Em T2, seleciona o funcionário;</li><li>Em T1, atualiza o salário do funcionário;</li><li>Por fim, seleciona o funcionário novamente.</li></ul><p>Para exercitar a situação, fizemos dois testes. Um teste com o nível de isolamento <strong>Read Committed</strong> para ver o fenômeno e outro com o nível de isolamento <strong>Repeatable Read</strong> onde não ocorre.</p><h4 id=teste-01>Teste 01</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_norepeatable_read_with_isolation_level_read_committed(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Beth Lee&#34;</span>, 3500))
</span></span><span style=display:flex><span>            id_employee, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>global</span> norepeatable_read_first_salary, norepeatable_read_second_salary
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                norepeatable_read_first_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                norepeatable_read_second_salary, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (4500, id_employee))                  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()         
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>            new_salary, = cur.fetchone()
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    self.assertNotEqual(norepeatable_read_first_salary, norepeatable_read_second_salary)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary, 4500)
</span></span></code></pre></div><p>No teste 01, observamos o fenômeno da leitura não repetível. O valor do salário do funcionário na primeira consulta difere do valor na segunda consulta do mesmo funcionário, pois o salário foi modificado entre as duas consultas.</p><h4 id=teste-02>Teste 02</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_norepeatable_read_with_isolation_level_repeatable_read(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Dep Tunner&#34;</span>, 3000))
</span></span><span style=display:flex><span>            id_employee, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>global</span> without_norepeatable_read_first_salary, without_norepeatable_read_second_salary
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                without_norepeatable_read_first_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                without_norepeatable_read_second_salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (4000, id_employee))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()         
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>            new_salary, = cur.fetchone()
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    self.assertEqual(without_norepeatable_read_first_salary, without_norepeatable_read_second_salary)
</span></span><span style=display:flex><span>    self.assertEqual(without_norepeatable_read_first_salary, 3000)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary, 4000)
</span></span></code></pre></div><p>Já no teste 02, não ocorre o fenômeno porque o nível de isolamento <strong>Repeatable Read</strong> impede isso e contexto dessa transação as leituras são repetíveis. O banco de dados resolveu ignorar que o valor foi atualizado.</p><p>Perceba que isso não é considerado um erro. Dependendo do contexto, ter dados mais atualizados pode ser fundamental para a regra de negócio. Em outros casos, a consistência dos dados é mais importante. <strong>É essencial identificar em quais situações esse fenômeno pode ser tolerado.</strong></p><h3 id=lost-update>Lost Update</h3><p>Lost Update, ou Atualização Perdida, é um fenômeno que ocorre quando duas transações tentam atualizar o mesmo registro e, devido à sobreescrita do dado por uma transação concomitante, uma delas acaba perdendo as informações. Esse fenômeno pode ocorrer no PostgreSQL quando o nível de isolamento está configurado como Read Committed, mas não ocorre no nível <strong>Repeatable Read</strong>. A imagem a seguir ilustra um exemplo desse fenômeno:</p><p><img src=../../images/lost_update.svg alt=image></p><ul><li>Em T1, seleciona o funcionário;</li><li>Em T2, seleciona o mesmo funcionário e, em seguida, atualiza o seu salário;</li><li>Por fim, em T1, atualiza o salário do funcionário, sobrescrevendo o dado.</li></ul><p>Novamente, realizamos dois testes: um com o nível de isolamento <strong>Read Committed</strong> para observar o fenômeno e outro com o nível de isolamento <strong>Repeatable Read</strong>, onde ele não ocorre.</p><h4 id=teste-01-1>Teste 01</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_lost_update_with_isolation_level_read_committed(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Mary Castle&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(3)
</span></span><span style=display:flex><span>                new_salary = salary * 1.1
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (new_salary, id_employee))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>                new_salary = salary * 1.2
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (new_salary, id_employee))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(salary, 4400)
</span></span></code></pre></div><p>No teste 01, observamos o fenômeno da atualização perdida. A primeira transação não refletiu as mudanças no salário feitas pela segunda transação, resultando na sobreescrita das informações da segunda transação.</p><h4 id=teste-02-1>Teste 02</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_lost_update_with_isolation_level_repeatable_read(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Bob Fox&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> cm_lost_update
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> self.assertRaises(Exception) <span style=color:#00f>as</span> cm_lost_update, psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(3)
</span></span><span style=display:flex><span>                new_salary = salary * 1.1
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (new_salary, id_employee))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>                new_salary = salary * 1.2
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (new_salary, id_employee))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee,))
</span></span><span style=display:flex><span>                salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(salary, 4800)
</span></span><span style=display:flex><span>    self.assertEqual(type(cm_lost_update.exception), psycopg.errors.SerializationFailure)
</span></span></code></pre></div><p>No cenário do teste 02, o banco de dados com o nível de isolamento <strong>Repeatable Read</strong> identifica o problema e retorna um erro de serialização, impedindo que o fenômeno de atualização perdida ocorra.</p><p>Para evitar comprometer a integridade dos dados com a atualização perdida, é preferível obter um erro ou identificar a situação e tentar novamente a transação com dados mais consistentes. Existem outras maneiras de tratar esse fenômeno, que serão discutidas em um próximo post.</p><h3 id=read-skew>Read Skew</h3><p>Read Skew ou Leitura Distorcida é um fenômeno onde as transações executam consultas sobre dados que podem sofrer alterações e retornam dados inconsistentes. Ele pode ocorrer no PostgreSQL quando está no nível de isolamento <strong>Read Committed</strong>, mas não ocorre no <strong>Repeatable Read</strong>.</p><p><img src=../../images/read_skew.svg alt=image></p><ul><li>T1 deseja selecionar os funcionários 1 e 2.</li><li>Durante a seleção dos dois funcionários, T2 atualiza os salários deles.</li><li>Como resultado, T1 obtém uma versão inconsistente dos dados: a informação do funcionário 1 desatualizada e a do funcionário 2 atualizada.</li></ul><p>Para simular o fenômeno, realizamos dois testes: um com o nível de isolamento Read Committed, onde ele ocorre, e outro com Repeatable Read, onde ele não ocorre.</p><h4 id=teste-01-2>Teste 01</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_read_skew_with_read_committed_isolation_level(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Selma Bates&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Samuel Bowen&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> read_skew_salary_employee1, read_skew_salary_employee2
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                read_skew_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                read_skew_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (5000, id_employee1))
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (5000, id_employee2))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                new_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                new_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(read_skew_salary_employee1, 4000)
</span></span><span style=display:flex><span>    self.assertEqual(read_skew_salary_employee2, 5000)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee1, 5000)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee2, 5000)
</span></span></code></pre></div><p>No teste acima, no primeiro conjunto de validações, observamos que o salário do primeiro funcionário ainda é o valor inicial, enquanto o salário do segundo funcionário já está atualizado. Isso demonstra o fenômeno da leitura distorcida. No entanto, ao verificarmos os valores dos salários após a conclusão das transações, confirmamos que ambos foram atualizados corretamente.</p><h4 id=teste-02-2>Teste 02</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_read_skew_with_repeatable_read_isolation_level(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Eric Wilson&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Roxy Clark&#34;</span>, 4000))
</span></span><span style=display:flex><span>            id_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> without_read_skew_salary_employee1, without_read_skew_salary_employee2
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                without_read_skew_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                without_read_skew_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (5000, id_employee1))
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (5000, id_employee2))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                new_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                new_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(without_read_skew_salary_employee1, 4000)
</span></span><span style=display:flex><span>    self.assertEqual(without_read_skew_salary_employee2, 4000)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee1, 5000)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee2, 5000)
</span></span></code></pre></div><p>No teste com o nível de isolamento Repeatable Read, o banco de dados intervém e mantém ambos os valores antigos, sem atualizações durante a transação de consulta dos funcionários no banco de dados. Isso pode ser necessário quando a funcionalidade exige dados consistentes no instante da consulta.</p><p>Esse fenômeno também ocorre quando há consultas em mais de uma tabela. Ao consultar outras tabelas, pode ocorrer uma alteração nos dados da tabela onde ocorreu a primeira consulta, resultando em inconsistências. Por simplicidade, mostramos o exemplo usando apenas uma tabela.</p><p>É importante lembrar que manter a sincronia dos dados de forma consistente é um desafio, especialmente quando há vários relacionamentos entre tabelas. Avalie cuidadosamente as possibilidades de vir a ocorrer o fenômeno da leitura distorcida ao consultar dados vitais para o seu negócio.</p><h3 id=write-skew>Write Skew</h3><p>Write Skew, ou Escrita Distorcida, também conhecido como Serialization Anomaly ou Anomalia na Serialização, é um fenômeno que ocorre quando transações modificam um dado baseado em uma leitura de dados que já não é mais a mesma. De acordo com o padrão SQL, isso não ocorre no nível de isolamento <strong>Repeatable Read</strong>, mas ocorre no PostgreSQL. Esse fenômeno é evitado no nível <strong>Serializable</strong>.</p><p><img src=../../images/write_skew.svg alt=image></p><ul><li>Em T1, ocorre a seleção do somatório dos salários dos funcionários.</li><li>Em T2, também é selecionado o somatório dos salários dos funcionários e, em seguida, o salário do funcionário 2 é atualizado com base nessa informação.</li><li>Por fim, em T1, o salário do funcionário 1 é atualizado com base no valor do primeiro somatório obtido, gerando o fenômeno de escrita distorcida.</li></ul><p>Ambas as transações consultam o mesmo dado (somatório de salários) e atualizam os salários de funcionários distintos. O fenômeno acontece porque, durante a atualização do salário do funcionário 1 em T1, o somatório dos salários foi alterado por T2.</p><p>No teste 01, replicamos o fenômeno de escrita distorcida, enquanto no teste 02 impedimos sua ocorrência ao aplicarmos o nível de isolamento <strong>Serializable</strong>.</p><h4 id=teste-01-3>Teste 01</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_write_skew_with_repeatable_read_isolation_level(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Selma Bates&#34;</span>, 5000))
</span></span><span style=display:flex><span>            id_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Samuel Bowen&#34;</span>, 9000))
</span></span><span style=display:flex><span>            id_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                total_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                increment_salary = 0.1 * total_salary
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=salary+</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (increment_salary, id_employee1))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                total_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                increment_salary = 0.1 * total_salary
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=salary+</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (increment_salary, id_employee2))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                new_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                new_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee1, 6400)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee2, 10400)
</span></span></code></pre></div><p>No teste 01, os salários dos funcionários são incrementados em 10% com base no somatório de salários. Se as transações fossem executadas sequencialmente, o segundo funcionário se beneficiaria do aumento de salário do primeiro, recebendo um aumento maior. No entanto, o fenômeno de escrita distorcida ocorre, resultando em ambos os funcionários recebendo o mesmo incremento.</p><h4 id=teste-02-3>Teste 02</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_write_skew_with_isolation_level_serializable(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Dean Knox&#34;</span>, 5000))
</span></span><span style=display:flex><span>            id_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>) RETURNING id&#34;</span>, (<span style=color:#a31515>&#34;Madison Frey&#34;</span>, 9000))
</span></span><span style=display:flex><span>            id_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> cm_write_skew
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> self.assertRaises(Exception) <span style=color:#00f>as</span> cm_write_skew, psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL SERIALIZABLE&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                total_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                increment_salary = 0.1 * total_salary
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=salary+</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (increment_salary, id_employee1))
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL SERIALIZABLE&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                total_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                increment_salary = 0.1 * total_salary
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;UPDATE employee SET salary=salary+</span><span style=color:#a31515>%s</span><span style=color:#a31515> WHERE id=</span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (increment_salary, id_employee2))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee1,))
</span></span><span style=display:flex><span>                new_salary_employee1, = cur.fetchone()
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT salary FROM employee WHERE id = </span><span style=color:#a31515>%s</span><span style=color:#a31515>&#34;</span>, (id_employee2,))
</span></span><span style=display:flex><span>                new_salary_employee2, = cur.fetchone()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.assertEqual(type(cm_write_skew.exception), psycopg.errors.SerializationFailure)        
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee1, 5000)
</span></span><span style=display:flex><span>    self.assertEqual(new_salary_employee2, 10400)
</span></span></code></pre></div><p>No teste 2, o banco de dados com o nível de isolamento mais agressivo detecta o caso de escrita distorcida e impede que um dos funcionários receba o aumento. Em vez de incrementar o salário, é lançado um erro de serialização. Isso faz sentido, já que a regra do incremento é aplicar 10% sobre o somatório dos salários atualizados. Se a transação que gerou o erro fosse refeita, o funcionário 1 receberia o aumento corretamente.</p><p>Esse fenômeno, assim como a leitura distorcida, também ocorre quando há consultas em mais de uma tabela. É necessário estar atento às possíveis ocorrências e verificar se são toleráveis dentro das regras de negócio.</p><h3 id=phanton-read>Phanton Read</h3><p>Phantom Read, ou Leitura Fantasma, ocorre quando uma transação depende de dados que podem ser modificados por outras transações. De acordo com o padrão SQL, esse fenômeno pode ocorrer no nível <strong>Repeatable Read</strong>, mas no PostgreSQL isso não acontece. No entanto, ele pode ser observado no nível <strong>Read Committed</strong>. A figura abaixo demonstra um exemplo desse fenômeno:</p><p><img src=../../images/phantom_read.svg alt=image></p><ul><li>Em T1, seleciona o somatório dos salários dos funcionários;</li><li>Em T2, insere um funcionário;</li><li>Por fim, em T1, seleciona novamente o somatório dos salários dos funcionários, que é diferente do valor selecionado anteriormente.</li></ul><p>Dois testes foram criados para verificar esse fenômeno em diferentes nível de isolamento: um teste com o nível de isolamento com <strong>Read Committed</strong> e outro com <strong>Repeatable Read</strong>.</p><h4 id=teste-01-4>Teste 01</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_phantom_read_with_read_committed_isolation_level(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Alan Rock&#34;</span>, 2500))
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Jess Tex&#34;</span>, 3000))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> phantom_read_first_sum_salary, phantom_read_second_sum_salary
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                phantom_read_first_sum_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                phantom_read_second_sum_salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Emma Crow&#34;</span>, 3500))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                sum_salary,  = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertNotEqual(phantom_read_first_sum_salary, phantom_read_second_sum_salary)
</span></span><span style=display:flex><span>    self.assertEqual(sum_salary, 9000)
</span></span></code></pre></div><p>No teste 01 acontece o fenômeno da leitura fantasma, pois entre a primeira e a segunda consulta do somatório dos salários ocorre a inserção de um novo funcionário.</p><h4 id=teste-02-4>Teste 02</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00f>def</span> test_without_phanton_read_with_repeatable_read_isolation_level(self):
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Rosie Cole&#34;</span>, 2500))
</span></span><span style=display:flex><span>            cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Iggy Bell&#34;</span>, 3000))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction1():
</span></span><span style=display:flex><span>        <span style=color:#00f>global</span> without_phanton_read_first_sum_salary, without_phanton_read_second_sum_salary
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                without_phanton_read_first_sum_salary, = cur.fetchone()
</span></span><span style=display:flex><span>                time.sleep(2)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                without_phanton_read_second_sum_salary, = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> transaction2():
</span></span><span style=display:flex><span>        <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ&#34;</span>)
</span></span><span style=display:flex><span>                time.sleep(1)
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;INSERT INTO employee (name, salary) VALUES (</span><span style=color:#a31515>%s</span><span style=color:#a31515>, </span><span style=color:#a31515>%s</span><span style=color:#a31515>)&#34;</span>, (<span style=color:#a31515>&#34;Hugo Cash&#34;</span>, 3500))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    threads = [Thread(target=transaction1), Thread(target=transaction2)]
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.start()
</span></span><span style=display:flex><span>    <span style=color:#00f>for</span> thread <span style=color:#00f>in</span> threads:
</span></span><span style=display:flex><span>        thread.join()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>with</span> psycopg.connect(self.connection_uri()) <span style=color:#00f>as</span> conn:
</span></span><span style=display:flex><span>            <span style=color:#00f>with</span> conn.cursor() <span style=color:#00f>as</span> cur:
</span></span><span style=display:flex><span>                cur.execute(<span style=color:#a31515>&#34;SELECT SUM(salary) FROM employee&#34;</span>)
</span></span><span style=display:flex><span>                sum_salary,  = cur.fetchone()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.assertEqual(without_phanton_read_first_sum_salary, without_phanton_read_second_sum_salary)
</span></span><span style=display:flex><span>    self.assertEqual(sum_salary, 9000)
</span></span></code></pre></div><p>No PostgreSQL, o nível de isolamento <strong>Repeatable Read</strong> impede o fenômeno da leitura fantasma, como podemos verificar no teste 02. É importante destacar que isso ocorre quando estamos realizando uma consulta de leitura numa base de dados enquanto outra transação está realizando inserções ou deleções de registros.</p><p>Esse caso é semelhante ao da leitura não repetível, com a diferença de que a leitura fantasma trabalha com um <strong>conjunto de dados</strong>, enquanto a leitura não repetível trabalha com o <strong>mesmo registro</strong>. Devemos avaliar se é aceitável, em termos de regras de negócio, não possuir a informação mais atualizada e como isso impacta as funcionalidades da sua aplicação.</p><h2 id=algumas-observações>Algumas observações</h2><p>Dentre os níveis de isolamento analisados, fica claro que o nível <strong>Serializable</strong> é o mais restritivo e impede a ocorrência de fenômenos que podem gerar inconsistências nos dados. No entanto, adotar o nível Serializable como padrão pode ser custoso e afetar o desempenho do banco de dados e do sistema. O isolamento é uma escolha entre <strong>maior consistência</strong> e <strong>maior concorrência</strong>. Devemos considerar:</p><ul><li>Tratamento de erros ou conflitos, se houver;</li><li>Limite de tempo da aplicação ou de negócio;</li><li>Retentativa de operações;</li><li>Consulta da documentação sobre o isolamento do banco de dados.</li></ul><p>Existem algumas abordagens para evitar ou detectar esses casos. Os protocolos mais comuns são:</p><ul><li><a href=https://en.wikipedia.org/wiki/Two-phase_locking>Two-phase locking (P2L)</a>, conhecido como bloqueio pessimista, utiliza travas ou bloqueios de recursos.</li><li><a href=https://en.wikipedia.org/wiki/Optimistic_concurrency_control>Optimistic concurrency control (OOC)</a>, conhecido como bloqueio otimista, permite a operação até detectar um conflito, revertendo a transação.</li></ul><p>O bloqueio pessimista evita qualquer operação ao bloquear o recurso, enquanto o bloqueio otimista evita bloqueios e se concentra em detectar conflitos. Vamos explorar esses protocolos no próximo post.</p><h2 id=e-por-hoje-é-só-pessoal>E por hoje é só, pessoal!</h2><p>Hoje aprofundamos o conceito de isolamento no A.C.I.D., seus níveis e os fenômenos que podem ocorrer, focando nossa análise em como garantir que nossa aplicação não tenha dados inconsistentes. Assim como no artigo anterior, abaixo estão alguns links interessantes que complementam esta leitura.</p><p>Agradecimento especial ao meu amigo <a href=https://gomesmr.substack.com/>Marcelo Gomes</a> pela revisão e melhorias deste artigo. Até o próximo artigo!</p><p><a href=https://dev.to/techschoolguru/understand-isolation-levels-read-phenomena-in-mysql-postgres-c2e>Deeply understand Isolation levels and Read phenomena in MySQL & PostgreSQL</a><br><a href=https://postgrespro.com/blog/pgsql/5967856>MVCC in PostgreSQL — 1. Isolation : Postgres Professional</a>
<a href=https://dzone.com/articles/sql-phenomena-for-developers>SQL Phenomena for Developers</a><br><a href=https://mkdev.me/posts/transaction-isolation-levels-with-postgresql-as-an-example>Transaction Isolation Levels With PostgreSQL as an example</a></p></div><div class=tags></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="alenvieira",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div class="footer wrapper"><nav class=nav><div>Exceto onde indicado de outra forma, todos os conteúdos neste site essão licenciados sob licença <a class=subfoot href=https://creativecommons.org/licenses/by/4.0/ rel=license>Creative Commons Atribuição 4.0 Internacional</a></div><div>Desenvolvido com <a href=https://gohugo.io>Hugo</a>, adaptando o tema <a href=https://github.com/knadh/hugo-ink>Ink</a></div></nav></div><script>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-123-45","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>